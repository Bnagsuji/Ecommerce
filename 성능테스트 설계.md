# 성능 테스트 설계 문서

---
#### 테스트 목적
본 부하 테스트는 주문/결제 서비스의 핵심 비즈니스 기능과 관련된 시스템 성능과 안정성을 검증하기 위해 수행되었다.
특히 인기상품 조회, 주문/결제, 포인트 충전 등의 실제 사용자 흐름을 반영하여, 서버 처리 능력과 동시성 문제를 확인하는 것이 목표이다.

#### 시나리오
**인기상품 조회 (Top-Selling 조회)**
* scenarioWarmTop 또는 scenarioHotBrowseAndOrder에서 수행
  /api/product/top-selling 호출 후, 반환된 인기 상품 목록 중 랜덤 상품 1개 선택
* 목적: 캐시 워밍업 및 주문 시 사용할 상품 확보
* 호출 비율: 초기 10~50 RPS 수준 (워밍업 단계)

**포인트 충전**

* scenarioSeedBalance에서 초기 시드 충전 수행:
  초반 820초 동안 **초당 50200회 충전 요청**, 총 수천 건 처리
* scenarioPeriodicTopup에서는 장시간 내구 테스트용으로 잔액 유지 목적 소액 충전
* 20% 확률로 포인트 충전 시뮬레이션 가능 (설정 추가 시)
* 잔액 조회 API 호출 포함 가능

**주문/결제 (Order)**

* scenarioHotBrowseAndOrder에서 수행
  선택된 인기 상품을 대상으로 /api/orders 호출
* 10% 확률로 주문 요청 시뮬레이션 가능 (랜덤화 적용 가능)
* 요청에는 상품 ID + 수량 포함 (pickQty로 랜덤 수량)
* 주문 상태 확인 (Order Status Check)
* 주문/결제는 이벤트 기반 처리
* 일정 시간 지연 후 /api/orders/{orderId} 호출하여 상태가 "COMPLETED"인지 확인
* 현재 스크립트에서는 sleep 후 단순 호출, 상태 체크 로직 추가 가능

##### 데이터 세팅

- 상품/재고 : 테스트용 상품 N개 + 충분한 재고
- 인기상품 조회 : Redis에 top-selling 사전 적재(혹은 DB 집계 + 캐시)
- 잔액: 사용자군에 초기 잔액 세팅

---    
#### 실행 환경

테스트 도구 : k6
모니터링 : InfluxDB/Grafana
DB: MySQL 8
Redis/Lock, Kafka
Windows host 접속: http://host.docker.internal:8080    
로컬 PC의 도커 컨테이너 활용


##### Spring 테스트 환경


- docker-compse 구성
    ```
          grafana:
            image: grafana/grafana-oss:9.5.2
            container_name: grafana
            ports:
              - "3000:3000"
            volumes:
              - ./grafana-provisioning:/etc/grafana/provisioning
              - ./grafana-dashboard:/dashboard
            depends_on:
              - prometheus
              - influxdb
            restart: always
            privileged: true
            networks: [monitoring]
            
          influxdb:
            image: influxdb:1.8
            container_name: influxdb
            ports:
              - "8086:8086"
            environment:
              - INFLUXDB_DB=k6
              - INFLUXDB_HTTP_AUTH_ENABLED=false
            volumes:
              - ./influxdb:/var/lib/influxdb
            networks: [monitoring]
        
          k6:
            image: grafana/k6
            container_name: k6
            volumes:
              - ./scripts:/scripts
              - ./k6-scripts:/scripts/k6-scripts
            environment:
              - BASE_URL=http://host.docker.internal:8080
              - K6_INFLUXDB_ADDR=http://influxdb:8086
              - K6_INFLUXDB_DATABASE=k6
            command: run -o influxdb=http://influxdb:8086/k6 /scripts/order.js
            extra_hosts:
              - "host.docker.internal:host-gateway"
            depends_on:
              - prometheus
              - influxdb
            networks: [monitoring]
        
        
        volumes:
          grafana_volume:
            external: true
          prometheus_volume:
            external: true
        
        networks:
          monitoring:
            driver: bridge            
    ```        

- build.gradle.kts 구성
  따로 추가하지 않았음 (prometheus 사용의 경우, 아래 내용 추가)
    ```
	//grafana(prometheus)
	runtimeOnly ("io.micrometer:micrometer-registry-prometheus")
    ```

- influxdb.yml 추가
    ```
    apiVersion: 1
    datasources:
      - name: InfluxDB v1 (k6)
        type: influxdb
        access: proxy
        url: http://influxdb:8086
        database: k6
        isDefault: false
        user: ""
        secureJsonData: {}
        editable: true
    ```

- application.yml 설정 추가

    ```
    management:
      endpoint:
        health:
          show-details: always
      endpoints:
        web:
          exposure:
            include: "*"
      metrics:
        enable:
          all: true
    ```
---

k6 스크립트

```
import http from 'k6/http';
import { check, sleep } from 'k6';

// ===== 환경 변수 =====
const MODE           = (__ENV.MODE || 'load').toLowerCase();     // load | endurance | stress(옵션)
const BASE_URL       = __ENV.BASE_URL || 'http://host.docker.internal:8080';

const USER_START     = Number(__ENV.USER_START || '1');
const USER_COUNT     = Number(__ENV.USER_COUNT || '2000');

const INITIAL_CHARGE = Number(__ENV.INITIAL_CHARGE || '50000');
const MAX_QTY        = Number(__ENV.MAX_QTY || '2');

const ORDER_RPS      = Number(__ENV.ORDER_RPS || '40');          // load/stress 기본 목표 RPS
const DURATION       = __ENV.DURATION || '1m';                   // load/stress 기본 기간

// endurance 전용 파라미터
const SOAK_RPS       = Number(__ENV.SOAK_RPS || '10');           // 내구 테스트 RPS
const SOAK_DURATION  = __ENV.SOAK_DURATION || '2h';              // 내구 테스트 기간
const TOPUP_RPS      = Number(__ENV.TOPUP_RPS || '1');           // 분산 충전 RPS

// 선택: 포인트 충전/캐시워밍 on/off
const SEED_BALANCE   = (__ENV.SEED_BALANCE || 'true').toLowerCase() === 'true';
const WARM_CACHE     = (__ENV.WARM_CACHE || 'true').toLowerCase() === 'true';

// top-selling이 비면 사용할 백업 상품
const FALLBACK_PRODUCT_IDS = (__ENV.FALLBACK_PRODUCT_IDS || '101,102,103')
.split(',').map(s => Number(s.trim())).filter(Boolean);

// ===== 공통 옵션/임계치 =====
function thresholds() {
return {
http_req_failed: ['rate<0.02'],
'http_req_duration{endpoint:top}':    ['p(95)<300'],
'http_req_duration{endpoint:detail}': ['p(95)<300'],
'http_req_duration{endpoint:order}':  ['p(95)<800'],
'http_req_duration{endpoint:charge}': ['p(95)<800'],
'checks{endpoint:top}':    ['rate>0.98'],
'checks{endpoint:detail}': ['rate>0.98'],
'checks{endpoint:order}':  ['rate>0.90'],
'checks{endpoint:charge}': ['rate>0.95'],
};
}

function buildOptions() {
const base = {
discardResponseBodies: true,   // 장기/고RPS 시 메모리 사용 줄이기
thresholds: thresholds(),
};

    if (MODE === 'endurance') {
        return {
            ...base,
            scenarios: {
                ...(WARM_CACHE ? {
                    warm_top_once: {               // 캐시 워밍: 짧게 top-selling만 두드림
                        executor: 'constant-arrival-rate',
                        rate: 50, timeUnit: '1s', duration: '10s',
                        preAllocatedVUs: 20, maxVUs: 50, exec: 'scenarioWarmTop',
                    },
                } : {}),
                ...(SEED_BALANCE ? {
                    seed_balance_once: {           // 초반 시드 충전(짧게)
                        executor: 'constant-arrival-rate',
                        rate: 50, timeUnit: '1s', duration: '20s',
                        preAllocatedVUs: 600, maxVUs: 1200, exec: 'scenarioSeedBalance',
                        startTime: WARM_CACHE ? '10s' : '0s',
                    },
                } : {}),
                periodic_topup: {                // 장기간 동안 계좌 잔액 보충
                    executor: 'constant-arrival-rate',
                    rate: TOPUP_RPS, timeUnit: '1s', duration: SOAK_DURATION,
                    preAllocatedVUs: Math.min(TOPUP_RPS * 2, 50),
                    maxVUs: Math.min(TOPUP_RPS * 5, 100),
                    exec: 'scenarioPeriodicTopup',
                    startTime: SEED_BALANCE ? '20s' : (WARM_CACHE ? '10s' : '0s'),
                },
                hot_browse_and_order: {          // 본 테스트(안정 RPS로 오래)
                    executor: 'constant-arrival-rate',
                    rate: SOAK_RPS, timeUnit: '1s', duration: SOAK_DURATION,
                    startTime: SEED_BALANCE ? '20s' : (WARM_CACHE ? '10s' : '0s'),
                    preAllocatedVUs: Math.min(SOAK_RPS * 4, 300),
                    maxVUs: Math.min(SOAK_RPS * 10, 800),
                    exec: 'scenarioHotBrowseAndOrder',
                    gracefulStop: '30s',
                },
            },
        };
    }

    if (MODE === 'load') {
        return {
            ...base,
            scenarios: {
                ...(WARM_CACHE ? {
                    warm_top_once: {
                        executor: 'constant-arrival-rate',
                        rate: 50, timeUnit: '1s', duration: '10s',
                        preAllocatedVUs: 20, maxVUs: 50, exec: 'scenarioWarmTop',
                    },
                } : {}),
                ...(SEED_BALANCE ? {
                    seed_balance_once: {
                        executor: 'constant-arrival-rate',
                        rate: 200, timeUnit: '1s', duration: '8s',
                        preAllocatedVUs: 120, maxVUs: 300, exec: 'scenarioSeedBalance',
                        startTime: WARM_CACHE ? '10s' : '0s',
                    },
                } : {}),
                // 워밍업 → 피크 유지 → 램프다운
                load_ramp_plateau: {
                    executor: 'ramping-arrival-rate',
                    preAllocatedVUs: Math.min(ORDER_RPS * 4, 400),
                    maxVUs: Math.min(ORDER_RPS * 10, 1200),
                    timeUnit: '1s',
                    startTime: SEED_BALANCE ? '12s' : (WARM_CACHE ? '10s' : '0s'),
                    stages: [
                        { target: Math.max(5, Math.floor(ORDER_RPS * 0.3)), duration: '1m' },
                        { target: Math.max(10, Math.floor(ORDER_RPS * 0.6)), duration: '1m' },
                        { target: ORDER_RPS, duration: DURATION },          // 평지 구간
                        { target: 0, duration: '30s' },                     // 램프다운
                    ],
                    exec: 'scenarioHotBrowseAndOrder',
                    gracefulStop: '30s',
                },
            },
        };
    }

    // 향후 테스트 
    return {
        ...base,
        scenarios: {
            step_up: {
                executor: 'ramping-arrival-rate',
                preAllocatedVUs: 200, maxVUs: 2000, timeUnit: '1s',
                stages: [
                    { target: 20, duration: '1m' },
                    { target: 50, duration: '2m' },
                    { target: 100, duration: '2m' },
                    { target: 150, duration: '2m' },
                    { target: 200, duration: '2m' },
                    { target: 0, duration: '30s' },
                ],
                exec: 'scenarioHotBrowseAndOrder',
                gracefulStop: '30s',
            },
        },
    };
}

export const options = buildOptions();

// ===== 유틸 =====
function jsonHeaders(tags = {}) {
return { headers: { 'Content-Type': 'application/json' }, tags };
}
const rnd = (n) => Math.floor(Math.random() * n);
function pickUserId() { return USER_START + rnd(USER_COUNT); }
function pickQty()    { return Math.max(1, rnd(MAX_QTY) + 1); }
function pickOne(arr) { return arr[rnd(arr.length)]; }

// ===== API =====
function getTopSelling() {
const res = http.get(`${BASE_URL}/api/product/top-selling`, { tags: { endpoint: 'top', method: 'GET' } });
check(res, { 'top 200': r => r.status === 200 }, { endpoint: 'top' });
if (res.status !== 200) return [];
try { const list = res.json(); return Array.isArray(list) ? list : []; } catch (_) { return []; }
}
function getProductDetail(id) {
const res = http.get(`${BASE_URL}/api/product/${id}`, { tags: { endpoint: 'detail', method: 'GET' } });
check(res, { 'detail 200': r => r.status === 200 }, { endpoint: 'detail' });
return res;
}
function chargeBalance(userId, amount) {
const res = http.post(`${BASE_URL}/api/balance/charge`, JSON.stringify({ userId, amount }),
jsonHeaders({ endpoint: 'charge', method: 'POST' }));
check(res, { 'charge 200': r => r.status === 200 }, { endpoint: 'charge' });
return res;
}
function placeOrder(userId, items) {
const res = http.post(`${BASE_URL}/api/orders`, JSON.stringify({ userId, items }),
jsonHeaders({ endpoint: 'order', method: 'POST' }));
check(res, { 'order 200|400': r => r.status === 200 || r.status === 400 }, { endpoint: 'order' });
return res;
}

// ===== setup & 시나리오 =====
export function setup() {
let topList = getTopSelling();
if (!topList || topList.length === 0) {
topList = FALLBACK_PRODUCT_IDS.map(id => ({ id }));
}
return { topIds: topList.map(p => p.id).filter(Boolean) };
}

export function scenarioWarmTop() {
getTopSelling();
sleep(0.02);
}

export function scenarioSeedBalance() {
const userId = pickUserId();
chargeBalance(userId, INITIAL_CHARGE);
sleep(0.01 + Math.random() * 0.03);
}

export function scenarioPeriodicTopup() {
const userId = pickUserId();
// 내구 테스트 동안 잔액이 바닥나지 않도록 소액 충전
chargeBalance(userId, Math.max(10000, Math.floor(INITIAL_CHARGE / 5)));
sleep(0.5 + Math.random() * 0.5);
}

export function scenarioHotBrowseAndOrder(data) {
const topIds = (data && data.topIds && data.topIds.length) ? data.topIds : FALLBACK_PRODUCT_IDS;
const pid = pickOne(topIds);
getProductDetail(pid);
placeOrder(pickUserId(), [{ productId: pid, quantity: pickQty() }]);
sleep(0.02 + Math.random() * 0.05);
}


```
        
   





    
    
    
    