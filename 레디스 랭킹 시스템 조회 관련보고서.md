# Redis 기반 랭킹 시스템 구현 보고서
---

## 1) 구현한 Redis 자료구조와 사용 이유

### 자료구조
- **Sorted Set(ZSET)** — 일자별 판매량 버킷
    - **Key**: `rank:prod:{yyyyMMdd}` (예: `rank:prod:20250821`)
    - **Member**: `productId` (문자열)
    - **Score**: 해당 일자의 누적 판매 수량
    - **TTL(코드)**: 1일

- **임시 합산 키(ZSET)** — 최근 N일 합산 결과
    - **Key**: `rank:prod:tmp:{days}d:{uuid}` (예: `rank:prod:tmp:2d:0b9...`)
    - **생성 방식**: `ZUNIONSTORE`로 일자 버킷들을 합산
    - **TTL(코드)**: 30초

### 사용 이유
- **실시간 랭킹 성능**: ZSET은 점수 기반 정렬이 내장되어 있어 TOP-N 조회가 빠름(`ZREVRANGE`).
- **DB 부하 분산**: 매 요청마다 RDB에서 집계/정렬하지 않고, 주문 시점에 **증분 업데이트**(`ZINCRBY`에 해당)로 부하를 Redis로 이전.
- **시간 버킷 관리**: `yyyyMMdd` 단위로 분할하여 **만료/복구/재집계가 용이**.

---

## 2) 설계 방식과 흐름

### A. 쓰기 경로(주문 성공 → 점수 증가)
- **메서드**: `incrOrder(List<OrderItem> items)`
- **로직**
    1. 오늘 키 계산: `rank:prod:{yyyyMMdd}`
    2. `RBatch` 파이프라인으로 각 상품 `addScoreAsync(productId, qty)`
    3. 오늘 키에 **TTL 1일** 부여
    4. `batch.execute()`로 일괄 전송
- **특징**
    - 파이프라인으로 **RTT 감소**
    - (권장) 서비스 상위에서 **DB 커밋 이후(afterCommit)** 호출하면 롤백 데이터가 랭킹에 반영되는 문제를 방지

### B. 읽기 경로(최근 N일 TOP-N 조회)
- **메서드**: `getTopForRecentDaysPipelined(int days, int limit)`
- **로직**
    1. `collectDayKeys(days)`로 오늘부터 과거 `days-1`일까지의 **일자 키 목록** 생성
    2. 임시 키 생성: `rank:prod:tmp:{days}d:{uuid}`
    3. `RBatch` 파이프라인으로 아래 3단계를 순서대로 전송
        - **합산**: `ZUNIONSTORE tmpKey [dayKeys...]`  ← 코드에서는 `RScriptAsync.evalAsync(...)`로 Lua에서 `redis.call('ZUNIONSTORE', ...)` 수행
        - **만료**: `EXPIRE tmpKey 30s`
        - **조회**: `ZREVRANGE tmpKey 0 (limit-1)`(Redisson의 `valueRangeReversedAsync` 호출)
    4. `batch.execute()` 실행 후 TOP-N productId를 획득
    5. `productRepository.findAllById`로 상품 메타 조회 → **순위 보존**하여 `ProductResponse`로 변환 후 반환
- **특징**
    - 파이프라인으로 왕복 지연(RTT) 최소화
    - 임시 키는 **요청별 UUID**를 사용 → **캐시 재사용 목적이 아닌** 일시 키(메모리 정리 목적의 30s TTL)

---

## 3) 트랜잭션/파이프라인 선택과 근거

- **현재 구현**
    - `RBatch` 파이프라인 + Lua(`ZUNIONSTORE`만) 조합
    - 장점: 단일 요청 대비 **왕복 지연 감소**, 구현 단순
---


## 결론

현재 구현은 **Sorted Set + 일자 버킷 + 요청시 합산 + 파이프라인**의 패턴으로,  
실시간 인기 상품 TOP-N을 빠르고 일관성 있게 제공할 수 있는 구조다.  
정확도/일관성 요구가 더 올라가면 **Lua 원자 처리**, **버킷 TTL 상향**, **고정 결과 키 캐싱**, **클러스터 해시태그**를 단계적으로 적용할 예정이다.
