# 동시성 문제 보고서
---

## 1. 주문 도메인

### 문제 식별
- 동시에 여러 사용자가 주문 요청을 보낼 경우, 재고가 충분하지 않아도 주문이 승인되는 문제가 발생할 수 있음
- 주문 요청은 상품 재고, 결제 계좌, 쿠폰 사용 등의 여러 의존 도메인을 포함함

### 문제 분석
- 주문 처리는 `PlaceOrderUseCaseImpl`을 통해 구현됨
- 단일 트랜잭션으로 묶여 있지만, 내부적으로 호출되는 재고/결제/쿠폰 처리에는 명시적 락이 없어 동시 접근 시 Race Condition 발생 가능
- 특히 재고나 계좌가 트랜잭션 사이에 변경될 경우, 정합성 없는 주문 상태가 저장될 수 있음

### 해결 방안
- 주문 생성 로직에서 각 도메인(재고, 계좌, 쿠폰)의 처리를 동일 트랜잭션 내에서 수행
- 각 도메인별로 비관적 락(PESSIMISTIC_WRITE)을 적용하여 트랜잭션 간 데이터 경합 제어
- 예외 발생 시 전체 주문 처리 트랜잭션을 롤백하여 정합성 확보

#### 트랜잭션 범위
- `PlaceOrderUseCaseImpl` 전체를 하나의 트랜잭션으로 묶음
- 주문 생성, 재고 차감, 계좌 차감, 쿠폰 사용이 모두 하나의 트랜잭션 안에서 처리되어야 정합성 보장 가능

#### 락 범위
- 상품 ID, 계좌 ID, 쿠폰 ID 단위로 개별 행에만 락 적용 (범위 최소화)
- 성능 저하와 데드락 위험을 줄이기 위해 필요한 자원에만 국한하여 락을 설정

---

## 2. 재고(Product) 도메인

### 문제 식별
- 다수의 주문이 동시에 들어올 경우, 하나의 상품 재고가 중복 차감되며 음수 재고 발생 가능

### 문제 분석
- `ProductServiceImpl`에서 재고 차감 시 상품 정보를 단순 조회한 뒤 수량을 차감하고 저장
- 트랜잭션 간 충돌로 인해 Lost Update 발생

### 해결 방안
- `ProductJpaRepository`에서 상품 ID로 비관적 락 획득

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT p FROM Product p WHERE p.id = :id")
Optional<Product> findByIdWithLock(Long id);
```

#### 트랜잭션 범위
- 상품 재고 차감 메서드 전체를 트랜잭션으로 설정 (`@Transactional`)
- 락 획득 → 수량 차감 → 저장까지 한 흐름으로 보장

#### 락 범위
- 상품 ID 단위로만 락 적용하여 필요한 대상만 제어

---

## 3. 계좌(Account) 도메인

### 문제 식별
- 동시에 잔액 충전/차감 요청이 들어올 경우, 정합성 없는 결과 발생

### 문제 분석
- 충전/차감 로직이 트랜잭션 내에서 락 없이 동작해 Race Condition 발생

### 해결 방안
- 비관적 락으로 충돌 사전 차단

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT a FROM Account a WHERE a.userId = :userId")
Optional<Account> findByUserIdWithLock(Long userId);
```

- 충돌 비용이 크고 반드시 정합성이 필요한 영역이므로 현재는 비관적 락 유지

#### 트랜잭션 범위
- 충전/차감 단위로 `@Transactional` 적용
- 한 요청 안에서 조회, 연산, 저장이 일괄 수행되어야 함

#### 락 범위
- 계좌의 사용자 ID 단위로만 락을 적용하여 병목 최소화

---

## 4. 쿠폰 도메인

### 문제 식별
- 선착순 쿠폰 발급 시, 동시에 여러 사용자가 접근하면 중복 발급 또는 수량 초과 발급 문제가 발생
- 실제로는 이미 소진된 쿠폰이 다른 사용자에게도 발급되는 현상이 발생할 수 있음

### 문제 분석
- CouponServiceImpl에서 쿠폰 수량 조회 → 차감 → UserCoupon 생성까지의 흐름이 명확히 정의되어 있음
- 하지만 동시 요청이 들어올 경우, 쿠폰 수량을 동일하게 읽고 동시에 차감 시도하는 Race Condition 발생
- 특히 선착순 쿠폰은 트래픽이 집중되는 구조이므로, 데이터 정합성 보장과 성능 간 균형이 중요함


### 해결 방안
- 쿠폰 정보를 조회할 때 @Lock(LockModeType.PESSIMISTIC_WRITE) 적용하여
DB 차원에서 동시 접근 차단

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT c FROM Coupon c WHERE c.id = :id")
Optional<Coupon> findByIdWithLock(Long id);
```

- Redis 기반 `@DistributedLock` 추가 적용 예정

#### 트랜잭션 범위
- 쿠폰 발급 요청 전체 (쿠폰 조회, 수량 차감, 사용자 쿠폰 저장) 단위로 트랜잭션 구성

#### 락 범위
- 쿠폰 ID 단위로만 락 적용

---

# 결론

동시성 문제를 도메인별로 식별하고, 각 도메인의 충돌 특성에 따라 비관적 락과 분산 락 등 적절한 DB 제어 메커니즘을 적용하였다.  
트랜잭션과 락 범위는 정합성과 성능을 고려해 최소화하되, 반드시 보호가 필요한 자원에 대해서는 명확히 제어하였다.  
향후 실제 운영 트래픽과 충돌 빈도를 기반으로 일부 도메인에 대해서는 낙관적 락 전환도 고려할 예정이다.
