# Redis 기반 선착순 쿠폰 발급 설계 보고서

---

## 1) 사용한 Redis 자료구조 & 이유
- **Hash** `coupon:{couponId}`: 메타/재고 보관(`id`, `name`, `discount_amount`, `stock`, `valid_from_ts`, `valid_to_ts`)  
  → 재고 `HINCRBY -1`로 **원자적 차감**, **TTL**=유효기간 종료까지.
- **Set** `coupon:issued:{couponId}`: 이미 발급된 사용자 추적  
  → `SISMEMBER`/`SADD`로 **중복 발급 방지** O(1). TTL은 Hash와 동일.
- **List** `coupon:issue:queue`: 비동기 **DB 영속화 큐** (payload JSON).  
  → API와 DB를 **분리**해 피크 처리, 소비자 수로 **수평 확장**.
- **List** `coupon:issue:dlq`: 실패 건 **격리(DLQ)**, 운영자 재처리.

---

## 2) 설계 방식 · 흐름
### A. 발급 API (`issueAsync`)
1. **ensureCouponLoaded**: DB→Redis 로딩(없을 때만), Hash/Set에 TTL 설정(유효기간 기준).
2. **Lua 실행**(원자 게이트): `keys=[couponHash, issuedSet, issueQueue]`, `argv=[userId, nowSec, couponId]`
    - Hash 존재 확인(미로드→`-4`)
    - 기간 체크(`-3`)
    - 중복 체크(Set) → `-2`
    - 재고 확인/차감(`HINCRBY -1`, 재고 없으면 `-1`)
    - 발급 기록(`SADD`)
    - **큐 적재**(`RPUSH` payload: `{couponId,userId,issuedAt}`)
    - **리턴**: 남은 재고(≥0) 또는 에러 코드
3. 결과 코드 매핑 → `IssueCouponResponse` (ACCEPTED/ SOLD_OUT/ DUP/ NOT_ACTIVE/ NOT_FOUND).

### B. 소비자 (`CouponIssueConsumer`)
- `@Scheduled(fixedDelay=150ms)`: `leftPop(queue, 1s)`로 payload 획득(없으면 skip).
- `processJob`(트랜잭션):
    - **멱등성**: `existsByUserIdAndCoupon_Id`로 이미 저장됐으면 **SKIP**
    - `UserCoupon` 저장(쿠폰 조회 포함) → 성공 로그
    - 예외 시 **DLQ**로 이동
- 필요 시 인스턴스/스레드 수 확대로 **병렬 처리**.

---

## 3) 일관성 · 트랜잭션 포인트
- **원자성**: 발급 판단은 **Lua 하나**로 처리(기간/중복/재고/큐잉 **모두 원자적**).
- **최종 일관성**: DB 저장은 **비동기**. 큐 소비 실패는 **DLQ** + DB단 **멱등 체크**로 안전.
- **이중 멱등**: Redis(Set) + DB(`existsBy...`)로 **중복 발급/중복 저장 방지**.

---

## 4) 키/TTL 정책
- `coupon:{id}` Hash TTL = `valid_to - now` (초).
- `coupon:issued:{id}` Set TTL = Hash와 동일.
- 큐/DLQ는 TTL 없음(소비/운영 정책으로 관리).

---

## 5) 장점
- **피크 흡수**: API는 Redis에서 즉시 판정, DB는 비동기로 처리 → 고부하에 유리.
- **선착순/중복 방지**: 기간·중복·재고를 **한 지점(Lua)** 에서 확정.
- **수평 확장**: 소비자 수를 늘려 처리량 선형 확장.

## 결론
Lua로 기간·중복·재고·큐잉을 한 번에 처리해 원자성과 정확도를 확보했다.
Redis 큐로 API와 DB를 분리해 피크 흡수와 수평 확장이 가능하다.
Redis(Set)·DB 멱등성과 TTL로 중복·유실·유효기간을 안정적으로 관리할 수 있다.
